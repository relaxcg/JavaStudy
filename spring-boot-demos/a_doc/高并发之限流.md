### 限流

> 当高并发或瞬时高并发是，为了保证系统的稳定性、可用性，系统以牺牲部分请求为代价
> 或者延迟处理请求为代价，保证系统整体服务可用。

### 算法

##### 令牌桶

Guava 之 RateLimiter

> RateLimiter 采用了一种“预获取令牌”的方式来保证一个线程所请求的全部令牌一定能得到满足，且是尽快的到满足（只要现有令牌不足，这一次的令牌请求就会进入这种模式）

获取令牌流程:

1. 获取令牌
2. 校验参数并加锁
3. 根据当前时间更新已保存的令牌数量和下一次免费获取令牌的时间（如果这个时间是过去，则更新为当前时间）
4. 计算获取令牌需要的时间（加上当令牌不足时，产生这些令牌需要的时间）
5. 更新下一次免费获取令牌的时间（当前值+4 的值）
6. 计算等待时间（更新下一次免费获取令牌的时间-当前时间和 0 的大值）

**SmoothBursty**: 平滑突发限流。在令牌充足时，会让请求直接通过而无需等待。**稳定限流器在令牌数充足时会让请求直接通过而无需等待**

**SmoothWarmingUp**: 平滑预热限流。随着请求增加导致令牌桶中的令牌数量减少后，令牌生成速率会缓慢提升到一个稳定值（预设的值）。**预热限流器则只会让第一个请求直接通过，之后的请求都会有等待时间（无论令牌数充足与否）**

> ps:所谓的预热，是指等待系统预热，所以 SmoothWarmingUp 在开始时，生成令牌的速率比较低，且获取令牌会有耗时。

#### 漏桶

流入速率不定，流出速率恒定，只处理流出的请求。
优点：请求处理一直都是固定速率，很稳定。
缺点：没有办法解决突发流量的情况。

#### 计数器

时间窗口：  
设置一个时间窗口内允许的最大请求量（比如 100），如果当前窗口请求数超过这个设定数量，则拒绝该窗口内之后的请求。

> ps: 当请求集中在两个时间窗口的临界点，则会产生请求的尖峰（会在 1 秒内产生 200 个请求）。

滑动时间窗口：  
如将 1 秒划分为 10 个格子，每个格子用单独的计数器计数当前 100 毫秒的请求。随着时间流动，窗口也跟着时间流动，每次都是计算最近 10 个格子的请求量。如果请求总数超过 100，则下一个格子里就拒绝全部请求。格子数量越多，对流量的控制也就越精细。

> ps: 滑动时间窗口的缺点是，需要一直占用内存空间保存最近一个时间窗口每个格子的请求计数。
